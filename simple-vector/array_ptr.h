#pragma once

#include <cstdlib>
#include <algorithm>

template <typename Type>
class ArrayPtr {
public:
	// Инициализирует ArrayPtr нулевым указателем
	ArrayPtr() = default;

	// Создаёт в куче массив из size элементов типа Type.
	// Если size == 0, поле raw_ptr_ должно быть равно nullptr
	explicit ArrayPtr(size_t size) {
		size_ = size;
		if (size == 0) {
			raw_ptr_ = nullptr;
			return;
		}
		raw_ptr_ = new Type[size]{};
	}

	// Конструктор из сырого указателя, хранящего адрес массива в куче либо nullptr
	explicit ArrayPtr(Type* raw_ptr) noexcept {
		raw_ptr_ = raw_ptr;
	}

	// Запрещаем копирование
	ArrayPtr(const ArrayPtr&) = delete;

	ArrayPtr(ArrayPtr&& other) {
		raw_ptr_ = std::move(other.raw_ptr_);
	}

	~ArrayPtr() {
		delete[] raw_ptr_;
		size_ = 0;
	}

	Type* begin() {
		return raw_ptr_;
	}

	Type* end() {
		return raw_ptr_ + size_;
	}

	// Запрещаем присваивание
	ArrayPtr& operator=(const ArrayPtr&) = delete;

	ArrayPtr& operator=(ArrayPtr&& other) {
		delete[] raw_ptr_;
		raw_ptr_ = std::move(other.raw_ptr_);
		return *this;
	}

	// Прекращает владением массивом в памяти, возвращает значение адреса массива
	// После вызова метода указатель на массив должен обнулиться
	[[nodiscard]] Type* Release() noexcept {
		Type* tmp = &raw_ptr_[0];
		//delete[] raw_ptr_;
		raw_ptr_ = nullptr;
		size_ = 0;
		return tmp;
	}

	// Возвращает ссылку на элемент массива с индексом index
	Type& operator[](size_t index) noexcept {
		Type& ret = raw_ptr_[index];
		return ret;
	}

	// Возвращает константную ссылку на элемент массива с индексом index
	const Type& operator[](size_t index) const noexcept {
		const Type& ret = raw_ptr_[index];
		return ret;
	}

	// Возвращает true, если указатель ненулевой, и false в противном случае
	explicit operator bool() const {
		return raw_ptr_ != nullptr;
	}

	// Возвращает значение сырого указателя, хранящего адрес начала массива
	Type* Get() const noexcept {
		return raw_ptr_;
	}

	// Обменивается значениям указателя на массив с объектом other
	void swap(ArrayPtr& other) noexcept {
		std::swap(raw_ptr_, other.raw_ptr_);
		std::swap(size_, other.size_);
	}

	size_t GetSize() {
		return size_;
	}

private:
	Type* raw_ptr_ = nullptr;
	size_t size_ = 0;
};
